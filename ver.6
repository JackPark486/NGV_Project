/**********************************************************************************************************************
 * \file Cpu0_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 * Ver.
 * - 2203161439 1. 가변저항기 ADC 값을 변경하면 PWM 가변을 통해 BLUE, RED LED 밝기 조절
 *              2. 가변저항기 ADC(7CH) -> Blue LED(PWM), 광센서 ADC(6CH) -> Red LED(PWM)
 *              3. 가변저항기 ADC(7CH)를 활용한 8구간 음계 구현 및 타이머를 활용한 부저 컨트롤
 *              4. 3번항목 함수화
 *              5. 광센서 함수화
 * - 2203161439 6. 인터럽트 구현 SW2 D3(port2) push시 RED LED 토글됨
 **********************************************************************************************************************/
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"

/* Address of Registers */
// SCU Registers
#define SCU_BASE        (0xF0036000)
#define SCU_WDT_CPU0CON0 (*(volatile unsigned int*)(SCU_BASE + 0x100))

#define LCK             1
#define ENDINIT         0

// GTM Registers
// GTM - CMU (Clock Management Unit)
#define GTM_BASE                    (0xF0100000)
#define GTM_CMU_CLK_EN              (*(volatile unsigned int*)(GTM_BASE + 0x00300)) // CMU Clock Enable Register
#define GTM_CMU_FXCLK_CTRL          (*(volatile unsigned int*)(GTM_BASE + 0x00344)) // CMU FXCLK Control Register

#define EN_FXCLK                    22  // GTM_CMU_CLK_EN, Enable all CMU_FXCLK
#define FXCLK_SEL                   0   // GTM_CMU_FXCLK_CTRL, Input Clock Selection for EN_FXCLK line

// GTM - TOM0 (Timer Output module)
#define GTM_TOM0_TGC0_GLB_CTRL      (*(volatile unsigned int*)(GTM_BASE + 0x08030)) // TOMi TGC0 Global Control Register
#define GTM_TOM0_TGC0_ENDIS_CTRL    (*(volatile unsigned int*)(GTM_BASE + 0x08070)) // TOMi TGC0 Enable/Disable Control Register
#define GTM_TOM0_TGC0_OUTEN_CTRL    (*(volatile unsigned int*)(GTM_BASE + 0x08078)) // TOMi TGC0 Output Enable Control Register
#define GTM_TOM0_TGC0_FUPD_CTRL     (*(volatile unsigned int*)(GTM_BASE + 0x08038)) // TOMi TGC0 Force Update Control Register
#define GTM_TOM0_CH1_CTRL           (*(volatile unsigned int*)(GTM_BASE + 0x08040)) // Control Register
#define GTM_TOM0_CH2_CTRL           (*(volatile unsigned int*)(GTM_BASE + 0x08080)) // Control Register
#define GTM_TOM0_CH1_SR0            (*(volatile unsigned int*)(GTM_BASE + 0x08044)) // Shadow Register
#define GTM_TOM0_CH2_SR0            (*(volatile unsigned int*)(GTM_BASE + 0x08084)) // Shadow Register
#define GTM_TOM0_CH1_SR1            (*(volatile unsigned int*)(GTM_BASE + 0x08048)) // Shadow Register
#define GTM_TOM0_CH2_SR1            (*(volatile unsigned int*)(GTM_BASE + 0x08088)) // Shadow Register

#define UPEN_CTRL1                  18  // GTM_TOM0_TGC0_GLB_CTRL, TOM channel 1 enable update or register CM0, CM1 and CLK_SRC
#define UPEN_CTRL2                  20  // GTM_TOM0_TGC0_GLB_CTRL,
#define HOST_TRIG                   0   // GTM_TOM0_TGC0_GLB_CTRL, Trigger request signal to update the register ENDIS_STAT and OUTEN_STAT

#define ENDIS_CTRL1                 2   // GTM_TOM0_TGC0_ENDIS_CTRL
#define ENDIS_CTRL2                 4   // GTM_TOM0_TGC0_ENDIS_CTRL

#define OUTEN_CTRL1                 2   // GTM_TOM0_TGC0_OUTEN_CTRL
#define OUTEN_CTRL2                 4   // GTM_TOM0_TGC0_OUTEN_CTRL

#define RSTCN0_CH1                  18  // GTM_TOM0_TGC0_FUPD_CTRL
#define RSTCN0_CH2                  20  // GTM_TOM0_TGC0_FUPD_CTRL
#define FUPD_CTRL1                  2   // GTM_TOM0_TGC0_FUPD_CTRL
#define FUPD_CTRL2                  4   // GTM_TOM0_TGC0_FUPD_CTRL

#define CLK_SRC_SR                  12  // 분주
#define SL                          11  // H:1 / L:0 선택

// GTM
#define GTM_CLC                     (*(volatile unsigned int*)(GTM_BASE + 0x9FD00))
#define GTM_TOUTSEL6                (*(volatile unsigned int*)(GTM_BASE + 0x9FD48))

#define DISS                        1
#define DISR                        0
#define SEL7                        14  // GTM_TOUTSEL6
#define SEL8                        16  // GTM_TOUTSEL6

/* Define PORT10 Registers for LED or PWM */
#define PORT10_BASE     (0xF003B000)
#define PORT10_IOCR0    (*(volatile unsigned int*)(PORT10_BASE + 0x10))
#define PORT10_OMR      (*(volatile unsigned int*)(PORT10_BASE + 0x04))

#define PC0             0
#define PC1             11
#define PC2             19

#define PCL1            17
#define PCL2            18

#define PS1             1
#define PS2             2

/* Define PORT02 Registers for Switch2 */
#define PORT02_BASE     (0xF003A200)
#define PORT02_IOCR0    (*(volatile unsigned int*)(PORT02_BASE + 0x10))
#define PORT02_IN       (*(volatile unsigned int*)(PORT02_BASE + 0x24))

#define P0              0
#define P1              1

/* VADC Registers */
#define VADC_BASE       (0xF0020000)
#define VADC_CLC        (*(volatile unsigned int*)(VADC_BASE + 0x000))  // Clock Control Register
#define VADC_GLOBCFG    (*(volatile unsigned int*)(VADC_BASE + 0x080))  //
#define VADC_G4ARBCFG   (*(volatile unsigned int*)(VADC_BASE + 0x1480)) // Arbitration Configuration Register, Group x
#define VADC_G4ARBPR    (*(volatile unsigned int*)(VADC_BASE + 0x1484)) // Arbitration Priority Register, Group x
#define VADC_G4ICLASS0  (*(volatile unsigned int*)(VADC_BASE + 0x14A0)) // Input Class Register 0, Group x
#define VADC_G4QMR0     (*(volatile unsigned int*)(VADC_BASE + 0x1504)) // Queue 0 Mode Register, Group x
#define VADC_G4QINR0    (*(volatile unsigned int*)(VADC_BASE + 0x1510)) // Queue 0 Input Register, Group x
#define VADC_G4CHCTR7   (*(volatile unsigned int*)(VADC_BASE + 0x161C)) // Channel y Control, Register, Group x
#define VADC_G4CHCTR6   (*(volatile unsigned int*)(VADC_BASE + 0x1618)) // Channel y Control, Register, Group x // 채널 바꾸면 이부분!!!
#define VADC_G4RES1     (*(volatile unsigned int*)(VADC_BASE + 0x1704)) // Result Register y, Group x


#define DISR            0   // VADC_CLC, Module Disable Request Bit
#define DISS            1   // VADC_CLC, Module Disable Status Bit

#define ANONC           0   // VADC_G4ARBCFG, Analog Converter Control (AD 컨버터 Normal 동작 설정)

#define ASEN0           24  // VADC_G4ARBPR, Arbitration Slot y Enable (Request Source x 사용 여부 설정)
#define CSM0            3   // VADC_G4ARBPR, Conversion Start Mode of Request Source x (시작 타이밍 설정)
#define PRIO0           0   // VADC_G4ARBPR, Priority of Request Source x (우선순위 설정)

#define CMS             8   // VADC_G4ICLASS0, Conversion Mode for Standard Conversions (변환 모드 설정)
#define STCS            0   // VADC_G4ICLASS0, Sample Time Control for Standard Conversions (샘플 타임 설정)

#define FLUSH           10  // VADC_G4QMR0, Flush Queue (conversion request clear 수행 여부)
#define TREV            9   // VADC_G4QMR0, Trigger Event (발생 여부 설정)
#define ENGT            0   // VADC_G4QMR0, Enable Gate (conversion request 생성 여부 설정)

#define RF              5   // VADC_G4QINR0, Refill
#define REQCHNR         0   // VADC_G4QINR0, Request Channel Number (Analog Input Channel 7로 설정)

#define RESPOS          21  // VADC_G4CHCTR7, Result Position (AD 값 정렬 모드)
#define RESREG          16  // VADC_G4CHCTR7, Result Register (AD 값 저장 레지스터)
#define ICLSEL          0   // VADC_G4CHCTR7, Input Class Select (Group 4의 Class 0과 Channel 7 연결)

#define VF              31  // VADC_G4RES1, Valid Flag (변환이 업데이트 되었는지 나타냄)
#define RESULT          0   // VADC_G4RES1, Result of Most Recent Conversion (변환 결과 레지스터)

/* Define SCU Registers for Interrupt */
#define SCU_BASE        (0xF0036000)
#define SCU_WDTSCON0    (*(volatile unsigned int*)(SCU_BASE + 0x0F0)) //Safety Critical Register
#define SCU_EICR1       (*(volatile unsigned int*)(SCU_BASE + 0x214)) //External Input Channel Register
#define SCU_IGCR0       (*(volatile unsigned int*)(SCU_BASE + 0x22C)) //Interrupt Gating Control Register

#define LCK             1   // SCU_WDTSCON0, lock 상태를 표시
#define ENDINIT         0   // SCU_WDTSCON0, safety 설정 상태 표시

#define IGP0            14  // SCU_IGCR0, Interrupt Gating Pattern
#define INP0            12  // SCU_EICR1, Input Node Pointer
#define EIEN0           11  // SCU_EICR1, External Input Enable
#define FEN0            8   // SCU_EICR1, Falling Edge Enable
#define REN0            9   // SCU_EICR1, Rising Edge Enable
#define EXIS0           4   // SCU_EICR1, External Input Selection (채널에 어떤 입력 선택?)

#define IGP1            30
#define INP1            28
#define EIEN1           27
#define FEN1            24
#define EXIS1           20

/* Define SRC Registers for Interrupt */
#define SRC_BASE        (0xF0038000) // Service Request Control Registers (SRC)
#define SRC_SCUERU0     (*(volatile unsigned int*)(SRC_BASE + 0xCD4))   //External Request Unit
#define SRC_SCUERU1     (*(volatile unsigned int*)(SRC_BASE + 0xCD8))

#define TOS             11  //SRC_SCUER, Type of Service Control
#define SRE             10  //SRC_SCUER, Service Request Enable
#define SRPN            0   //SRC_SCUER, Service Request Priority Number (ID와 같은 개념)

/* Variable */
volatile int cnt2 = 0;
volatile int see = 0;
volatile int bbb = 0;
volatile int ccc = 0;
volatile int ddd = 0;
volatile int eee = 0;
volatile int Touch_PWM = 0;
unsigned volatile int Buzzer_Cnt = 0;
unsigned volatile int Buzzer_Key = 0;
unsigned volatile int Buzzer_Level = 0;
unsigned volatile int Buzzer_Level_b = 0;
unsigned volatile int Touch_Signal = 0;
unsigned volatile int adcResult;
int Buzzer[10] = {0};

/* Function Prototype */
void init_LED(void);
void init_GTM_TOM0_PWM(void);
void init_VADC(void);
void init_Switch(void);
void init_ERU(void);
unsigned int GetVADC4(int channel);
unsigned int BuzzerLevelDetector(int adcValue);
unsigned int TouchDetector(int adcValue);

IfxCpu_syncEvent g_cpuSyncEvent = 0;

int core0_main(void)
{
    IfxCpu_enableInterrupts();

    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());

    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);

    init_GTM_TOM0_PWM();
    init_VADC();                // Initialize VADC
    init_ERU();                 // Initialize ERU
    init_LED();                 // Initialize LED
    init_Switch();              // Initialize Switch
    while(1)
    {
        ccc = TouchDetector(GetVADC4(6));           // GetVADC4(6) -> 광센서(6) ADC

        bbb = BuzzerLevelDetector(GetVADC4(7));     // GetVADC4(7) -> 가변저항(7) ADC
    }
    return (1);
}

void init_LED(void)
{
    PORT10_IOCR0 &= ~((0x1F) << PC1);           // Reset PC1 in IOCR0
//    PORT10_IOCR0 |= ((0x11) << PC1);            // PORT10.1 : Alternate output function 1 (push-pull), GTM_TOUT103
    PORT10_IOCR0 |= ((0x10) << PC1);            // PORT10.2 : GPIO, RED LED

    PORT10_IOCR0 &= ~((0x1F) << PC2);           // Reset PC2 in IOCR0
    PORT10_IOCR0 |= ((0x11) << PC2);            // PORT10.2 : Alternate output function 1 (push-pull), GTM_TOUT104
//    PORT10_IOCR0 |= ((0x10) << PC2);            // PORT10.2 : GPIO, BLUE LED
}

/* Initialize Switch2 */
void init_Switch(void)
{
    /* Reset PC1 and PC0 in IOCR0*/
    PORT02_IOCR0 &= ~((0x1F) << PC1);
    PORT02_IOCR0 &= ~((0x1F) << PC0);

    /* Set PC1 and PC0 with pull-up(2b0xx10) */
    PORT02_IOCR0 |= ((0x2) << PC1);     // 0x2 : pull-up device connected
    PORT02_IOCR0 |= ((0x2) << PC0);
}

/* Initialize External Request Unit (ERU) */
void init_ERU(void)
{
    /* ERU Input Channel 2 Setting */
    /* Password Access to unlock WDTSCON0 */
    SCU_WDTSCON0 = ((SCU_WDTSCON0 ^ 0xFC) & ~(1 << LCK)) | (1 << ENDINIT);
    while((SCU_WDTSCON0 & (1 << LCK)) != 0);    // lock 되어있으면 1이고 1 != 0 을 만족하므로 넘어가지 않는다.

    // Modify Access to clear ENDINIT bit
    SCU_WDTSCON0 = ((SCU_WDTSCON0 ^ 0xFC) | (1 << LCK)) & ~ (1 << ENDINIT);
    while((SCU_WDTSCON0 & (1 << LCK)) == 0);

    SCU_EICR1 &= ~(((0x7) << EXIS0) | ((0x7) << EXIS1));    // External input clear
    SCU_EICR1 &= ~(((0x7) << INP0) | ((0x7) << INP1));      // Input Node Pointer Clear
    SCU_IGCR0 &= ~(((0x3) << IGP0) | ((0x3) << IGP1));      // Interrupt Gating Patten 2, 3 Clear

    SCU_EICR1 |= (0x1 << EXIS0)     |                       // P02.1 select
                 (0x2 << EXIS1)     ;                       // P02.0 select

    SCU_EICR1 |= (0x1 << FEN0)      |                       // Falling edge enable
                 (0x1 << FEN1)      ;

    SCU_EICR1 |= (0x1 << EIEN0)     |                       // The trigger event is enabled
                 (0x1 << EIEN1)     ;

    SCU_EICR1 |= (0x0 << INP0)      |                       // Trigger Input Channel 2 -> Output Channel 0
                 (0x1 << INP1)      ;                       // Trigger Input Channel 3 -> Output Channel 1

    SCU_IGCR0 |= (0x1 << IGP0)      |                       // Input Channel 2 activated, pattern is not considered
                 (0x1 << IGP1)      ;                       // Input Channel 3 activated, pattern is not considered


    /* SRC Interrupt Setting For ECU */
    SRC_SCUERU0 &= ~((0xFF) << SRPN);           // Set Priority : 0x0A
    SRC_SCUERU0 |= ((0x0A) << SRPN);

    SRC_SCUERU0 |= (1 << SRE);                  // Service Request is enabled

    SRC_SCUERU1 &= ~((0xFF) << SRPN);           // Clear Priority
    SRC_SCUERU1 |= ((0x0B) << SRPN);            // Set Priority : 0x0B

    SRC_SCUERU1 &= ~((0x3) << TOS);             // CPU0 services

    SRC_SCUERU1 |= (1 << SRE);                  // Service Request is enabled
}

void init_GTM_TOM0_PWM(void)
{
    /* GTM Enable */
    // Password Access to unlock WDTCPU0CON0
    SCU_WDT_CPU0CON0 = ((SCU_WDT_CPU0CON0 ^ 0xFC) & ~(1 << LCK)) | (1 << ENDINIT);
    while((SCU_WDT_CPU0CON0 & (1 << LCK)) != 0);

    // Modify Access to clear ENDINIT bit
    SCU_WDT_CPU0CON0 = ((SCU_WDT_CPU0CON0 ^ 0xFC) | (1 << LCK)) & ~(1 << ENDINIT);
    while((SCU_WDT_CPU0CON0 & (1 << LCK)) == 0);

    GTM_CLC &= ~(1 << DISR);                        // Enable GTM Module

    // Password Access to unlock WDTCPU0CON0
    SCU_WDT_CPU0CON0 = ((SCU_WDT_CPU0CON0 ^ 0xFC) & ~(1 << LCK)) | (1 << ENDINIT);
    while((SCU_WDT_CPU0CON0 & (1 << LCK)) != 0);

    // Modify Access to set ENDINIT bit
    SCU_WDT_CPU0CON0 = ((SCU_WDT_CPU0CON0 ^ 0xFC) | (1 << LCK)) | (1 << ENDINIT);
    while((SCU_WDT_CPU0CON0 & (1 << LCK)) == 0);

    while((GTM_CLC & (1 << DISS)) != 0);            // Wait until module is enabled



    /* GTM Clock Setting */
    GTM_CMU_FXCLK_CTRL &= ~((0xF) << FXCLK_SEL);    // Input clock of CMU_FXCLK : CMU_GCLK_EN

    GTM_CMU_CLK_EN |= ((0x2) << EN_FXCLK);          // Enable all CMU_FXCLK




    /* GTM TOM0 PWM Setting */
    GTM_TOM0_TGC0_GLB_CTRL |= ((0x2) << UPEN_CTRL1);    // TOM0 channel 1 enable update of
                                                        // register CM0, CM1, CLK_SRC

    GTM_TOM0_TGC0_FUPD_CTRL |= ((0x2) << FUPD_CTRL1);   // Enable force update of TOM0 channel 1
    GTM_TOM0_TGC0_FUPD_CTRL |= ((0x2) << RSTCN0_CH1);   // Reset CN0 of TOM0 channel 1 on force update

    GTM_TOM0_TGC0_ENDIS_CTRL |= ((0x2) << ENDIS_CTRL1); // Enable channel 1 on an update trigger
    GTM_TOM0_TGC0_OUTEN_CTRL |= ((0x2) << OUTEN_CTRL1); // Enable channel 1 output on an update trigger

    GTM_TOM0_CH1_CTRL |= (1 << SL);                     // High signal level for duty cycle

    GTM_TOM0_CH1_CTRL &= ~((0x7) << CLK_SRC_SR);        // Clock source : CMU_FXCLK(1) = 6250 kHz <- 100Mhz/16
    GTM_TOM0_CH1_CTRL |= (1 << CLK_SRC_SR);             // FXCLKSEL/2^4
    GTM_TOM0_CH1_SR0 = 12500 - 1;                       // PWM freq. = 6250 kHz / 12500 = 500 Hz
//    GTM_TOM0_CH1_SR1 = 0;                               // Duty cycle = 0
    GTM_TOM0_CH1_SR1 = 6250-1;                          // Duty cycle = 50
//    GTM_TOM0_CH1_SR1 = 12500 - 1;                       // Duty cycle = 100




    /* GTM TOM0 PWM Setting */
    GTM_TOM0_TGC0_GLB_CTRL |= ((0x2) << UPEN_CTRL2);    // TOM0 channel 2 enable update of
                                                        // register CM0, CM1, CLK_SRC

    GTM_TOM0_TGC0_FUPD_CTRL |= ((0x2) << FUPD_CTRL2);   // Enable force update of TOM0 channel 2
    GTM_TOM0_TGC0_FUPD_CTRL |= ((0x2) << RSTCN0_CH2);   // Reset CN0 of TOM0 channel 2 on force update

    GTM_TOM0_TGC0_ENDIS_CTRL |= ((0x2) << ENDIS_CTRL2); // Enable channel 2 on an update trigger
    GTM_TOM0_TGC0_OUTEN_CTRL |= ((0x2) << OUTEN_CTRL2); // Enable channel 2 output on an update trigger

    GTM_TOM0_CH2_CTRL |= (1 << SL);                     // High signal level for duty cycle

    GTM_TOM0_CH2_CTRL &= ~((0x7) << CLK_SRC_SR);        // Clock source : CMU_FXCLK(1) = 6250 kHz
    GTM_TOM0_CH2_CTRL |= (1 << CLK_SRC_SR);
    GTM_TOM0_CH2_SR0 = 12500 - 1;                       // PWM freq. = 6250 kHz / 12500 = 500 Hz
//    GTM_TOM0_CH2_SR1 = 0;                               // Duty cycle = 0
    GTM_TOM0_CH2_SR1 = 3250-1;                          // Duty cycle = 30
//    GTM_TOM0_CH2_SR1 = 12500 - 1;                       // Duty cycle = 100


    GTM_TOUTSEL6 &= ~((0x3) << SEL7);                   // TOUT103 : TOM0 channel 1
    GTM_TOUTSEL6 &= ~((0x3) << SEL8);                   // TOUT104 : TOM0 channel 2

    GTM_TOM0_TGC0_GLB_CTRL |= (1 << HOST_TRIG);         // Trigger request signal to update

}

void init_VADC(void)
{
    /* VADC Enable */
    /* Password Access to unlock WDTCPU0CON0 */
    SCU_WDT_CPU0CON0 = ((SCU_WDT_CPU0CON0 ^ 0xFC) & ~(1 << LCK)) | (1 << ENDINIT);
    while((SCU_WDT_CPU0CON0 & (1 << LCK)) != 0);

    /* Modify Access to clear ENDINIT bit */
    SCU_WDT_CPU0CON0 = ((SCU_WDT_CPU0CON0 ^ 0xFC) | (1 << LCK)) & ~ (1 << ENDINIT);
    while((SCU_WDT_CPU0CON0 & (1 << LCK)) == 0);

    VADC_CLC &= ~(1 << DISR);                 // Enable VADC Module

    /* Password Access to unlock WDTSCPU0CON0 */
    SCU_WDT_CPU0CON0 = ((SCU_WDT_CPU0CON0 ^ 0xFC) & ~(1 << LCK)) | (1 << ENDINIT);
    while((SCU_WDT_CPU0CON0 & (1 << LCK)) != 0);

    /* Modify Access to clear ENDINIT bit */
    SCU_WDT_CPU0CON0 = ((SCU_WDT_CPU0CON0 ^ 0xFC) | (1 << LCK)) | (1 << ENDINIT);
    while((SCU_WDT_CPU0CON0 & (1 << LCK)) == 0);

    while((VADC_CLC & (1 << DISS)) != 0);     // Wait until module is enabled

    VADC_G4ARBPR |= ((0x3) << PRIO0);         // Highest Priority for Request Source 0
    VADC_G4ARBPR &= ~(1 << CSM0);             // Conversion Start Mode : Wait-for-start mode
    VADC_G4ARBPR |= (1 << ASEN0);             // Arbitration Source Input 0 Enable

    VADC_G4QMR0  &= ~((0x3) << ENGT);         // Enable Conversion Requests
    VADC_G4QMR0  |= ((0x1) << ENGT);

    VADC_G4QMR0  |= (1 << FLUSH);             // Clear all Queue Entries

    VADC_G4ARBCFG |= ((0x3) << ANONC);        // Analog Converter : Normal Operation

    VADC_G4ICLASS0 &= ~((0x7) << CMS);        // Group-specific Class 0
                                              // Conversion Mode : Standard Conversion (12-bit)

    /* VADC Group 4 Channel 7 Setting */
    VADC_G4CHCTR7 |= (1 << RESPOS);           // Read Results Right-aligned
    VADC_G4CHCTR7 &= ~((0xF) << RESREG);      // Store Result in Group Result Register G4RES1
    VADC_G4CHCTR7 |= (1 << RESREG);
    VADC_G4CHCTR7 &= ~((0x3) << ICLSEL);      // Use Group-specific Class 0

    /* VADC Group 4 Channel 6 Setting */        // 채널 바꾸면 이부분!!!
    VADC_G4CHCTR6 |= (1 << RESPOS);           // Read Results Right-aligned
    VADC_G4CHCTR6 &= ~((0xF) << RESREG);      // Store Result in Group Result Register G4RES1
    VADC_G4CHCTR6 |= (1 << RESREG);
    VADC_G4CHCTR6 &= ~((0x3) << ICLSEL);      // Use Group-specific Class 0
}

unsigned int GetVADC4(int channel)
{
    unsigned int result;

    VADC_G4QINR0 = channel;
    VADC_G4QMR0 |= (1 << TREV);                     // Generate a Trigger Event

    while((VADC_G4RES1 & (1 << VF)) == 0);          // Wait until New Result Available

    result = (VADC_G4RES1 & ((0xFFFF) << RESULT));  // Read Result

    return result;
}

unsigned int TouchDetector(int adcValue)
{
    Touch_PWM=adcValue*3-7000;
    if(Touch_PWM <= 0){Touch_PWM = 0;}          // 0이하 컷
    GTM_TOM0_CH1_SR1 = Touch_PWM;    // RED LED PWM

    if(Touch_PWM < 3000){Touch_Signal = 1;}
    else{Touch_Signal = 0;}

    return Touch_Signal;
}
unsigned int BuzzerLevelDetector(int adcValue)
{
    if(adcValue >= 4096 * 0.125 * 7)   // ADC 4096을 8음계로 구간을 나눔
    {
        Buzzer_Level = 7;               // 음계 8번째 레벨
        if(Buzzer_Key == 0){GTM_TOM0_CH2_SR1 = 12499 * 0.125 * 7;}// LED BLUE PWM Set, 음계의 0.1초간 실행을 위해 부저_키 활용
        Buzzer_Cnt++;                   // 0.1초 카운팅

        if(Buzzer_Cnt == 100000){       // 0.1초 카운팅
            GTM_TOM0_CH2_SR1 = 0;                   // LED BLUE PWM Clear
            Buzzer_Cnt = 0;             // 부저 카운트 초기화
            Buzzer_Key = 1;             // 부저 첫 실행 방지를 위한 플래그
        }
    }
    else if(adcValue >= 4096 * 0.125 * 6)
    {
        Buzzer_Level = 6;
        if(Buzzer_Key == 0){GTM_TOM0_CH2_SR1 = 12499 * 0.125 * 6;}
        Buzzer_Cnt++;

        if(Buzzer_Cnt == 100000){
            GTM_TOM0_CH2_SR1 = 0;
            Buzzer_Cnt = 0;
            Buzzer_Key = 1;
        }
    }
    else if(adcValue >= 4096 * 0.125 * 5)
    {
        Buzzer_Level = 5;
        if(Buzzer_Key == 0){GTM_TOM0_CH2_SR1 = 12499 * 0.125 * 5;}
        Buzzer_Cnt++;

        if(Buzzer_Cnt == 100000){
            GTM_TOM0_CH2_SR1 = 0;
            Buzzer_Cnt = 0;
            Buzzer_Key = 1;
        }
    }
    else if(adcValue >= 4096 * 0.125 * 4)
    {
        Buzzer_Level = 4;
        if(Buzzer_Key == 0){GTM_TOM0_CH2_SR1 = 12499 * 0.125 * 4;}
        Buzzer_Cnt++;

        if(Buzzer_Cnt == 100000){
            GTM_TOM0_CH2_SR1 = 0;
            Buzzer_Cnt = 0;
            Buzzer_Key = 1;
        }
    }
    else if(adcValue >= 4096 * 0.125 * 3)
    {
        Buzzer_Level =3;
        if(Buzzer_Key == 0){GTM_TOM0_CH2_SR1 = 12499 * 0.125 * 3;}
        Buzzer_Cnt++;

        if(Buzzer_Cnt == 100000){
            GTM_TOM0_CH2_SR1 = 0;
            Buzzer_Cnt = 0;
            Buzzer_Key = 1;
        }
    }
    else if(adcValue >= 4096 * 0.125 * 2)
    {
        Buzzer_Level = 2;
        if(Buzzer_Key == 0){GTM_TOM0_CH2_SR1 = 12499 * 0.125 * 2;}
        Buzzer_Cnt++;

        if(Buzzer_Cnt == 100000){
            GTM_TOM0_CH2_SR1 = 0;
            Buzzer_Cnt = 0;
            Buzzer_Key = 1;
        }
    }
    else if(adcValue >= 4096 * 0.125 * 1)
    {
        Buzzer_Level =1;
        if(Buzzer_Key == 0){GTM_TOM0_CH2_SR1 = 12499 * 0.125 * 1;}
        Buzzer_Cnt++;

        if(Buzzer_Cnt == 100000){
            GTM_TOM0_CH2_SR1 = 0;
            Buzzer_Cnt = 0;
            Buzzer_Key = 1;
        }
    }
    else
    {
        Buzzer_Level = 0;
        if(Buzzer_Key == 0){GTM_TOM0_CH2_SR1 = 12499 * 0.125 * 0;}
        Buzzer_Cnt++;

        if(Buzzer_Cnt == 100000){
            GTM_TOM0_CH2_SR1 = 0;
            Buzzer_Cnt = 0;
            Buzzer_Key = 1;
        }
    }

    if (Buzzer_Level_b != Buzzer_Level){Buzzer_Key = 0; Buzzer_Cnt = 0;}    //부저 레벨이 변하는지 감시하기 위함
    Buzzer_Level_b = Buzzer_Level;                      // 현재 부저 레벨 저장

    return Buzzer_Level;
}

__interrupt(0x0A) __vector_table(0)
void ERU0_ISR(void)
{
    PORT10_OMR |= ((1<<PCL1) | (1<<PS1));           // Toggle LED RED
}

__interrupt(0x0B) __vector_table(0)
void ERU1_ISR(void)
{
//    PORT10_OMR |= ((1<<PCL2) | (1<<PS2));           // Toggle LED BLUE
}
